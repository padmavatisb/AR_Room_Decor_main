{"ast":null,"code":"import _assertThisInitialized from \"C:/Users/Padmavati Shankar/3D-WebXR-Furniture/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Padmavati Shankar/3D-WebXR-Furniture/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Padmavati Shankar/3D-WebXR-Furniture/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/Padmavati Shankar/3D-WebXR-Furniture/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Padmavati Shankar/3D-WebXR-Furniture/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DirectionalLight, Group, LightProbe, WebGLCubeRenderTarget } from 'three';\nvar SessionLightProbe = /*#__PURE__*/function () {\n  function SessionLightProbe(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    var _this = this;\n    _classCallCheck(this, SessionLightProbe);\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    var session = renderer.xr.getSession();\n\n    // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      var cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      var gl = renderer.getContext();\n\n      // Ensure that we have any extensions needed to use the preferred cube map format.\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', function () {\n        _this.updateReflection();\n      });\n    }\n\n    // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  _createClass(SessionLightProbe, [{\n    key: \"updateReflection\",\n    value: function updateReflection() {\n      var textureProperties = this.renderer.properties.get(this.xrLight.environment);\n      if (textureProperties) {\n        var cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n        if (cubeMap) {\n          textureProperties.__webglTexture = cubeMap;\n          this.xrLight.environment.needsPMREMUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"onXRFrame\",\n    value: function onXRFrame(time, xrFrame) {\n      // If either this obejct or the XREstimatedLight has been destroyed, stop\n      // running the frame loop.\n      if (!this.xrLight) {\n        return;\n      }\n      var session = xrFrame.session;\n      session.requestAnimationFrame(this.frameCallback);\n      var lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n      if (lightEstimate) {\n        // We can copy the estimate's spherical harmonics array directly into the light probe.\n        this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n        this.xrLight.lightProbe.intensity = 1.0;\n\n        // For the directional light we have to normalize the color and set the scalar as the\n        // intensity, since WebXR can return color values that exceed 1.0.\n        var intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n        this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n        this.xrLight.directionalLight.intensity = intensityScalar;\n        this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n        if (this.estimationStartCallback) {\n          this.estimationStartCallback();\n          this.estimationStartCallback = null;\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.xrLight = null;\n      this.renderer = null;\n      this.lightProbe = null;\n      this.xrWebGLBinding = null;\n    }\n  }]);\n  return SessionLightProbe;\n}();\nexport var XREstimatedLight = /*#__PURE__*/function (_Group) {\n  _inherits(XREstimatedLight, _Group);\n  var _super = _createSuper(XREstimatedLight);\n  function XREstimatedLight(renderer) {\n    var _this2;\n    var environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, XREstimatedLight);\n    _this2 = _super.call(this);\n    _this2.lightProbe = new LightProbe();\n    _this2.lightProbe.intensity = 0;\n    _this2.add(_this2.lightProbe);\n    _this2.directionalLight = new DirectionalLight();\n    _this2.directionalLight.intensity = 0;\n    _this2.add(_this2.directionalLight);\n\n    // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n    _this2.environment = null;\n    var sessionLightProbe = null;\n    var estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', function () {\n      var session = renderer.xr.getSession();\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(function (probe) {\n          sessionLightProbe = new SessionLightProbe(_assertThisInitialized(_this2), renderer, probe, environmentEstimation, function () {\n            estimationStarted = true;\n\n            // Fired to indicate that the estimated lighting values are now being updated.\n            _this2.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        _this2.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    });\n\n    // Done inline to provide access to sessionLightProbe.\n    _this2.dispose = function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      _this2.remove(_this2.lightProbe);\n      _this2.lightProbe = null;\n      _this2.remove(_this2.directionalLight);\n      _this2.directionalLight = null;\n      _this2.environment = null;\n    };\n    return _this2;\n  }\n  return _createClass(XREstimatedLight);\n}(Group);","map":{"version":3,"names":["DirectionalLight","Group","LightProbe","WebGLCubeRenderTarget","SessionLightProbe","xrLight","renderer","lightProbe","environmentEstimation","estimationStartCallback","_this","_classCallCheck","xrWebGLBinding","frameCallback","onXRFrame","bind","session","xr","getSession","window","cubeRenderTarget","environment","texture","gl","getContext","preferredReflectionFormat","getExtension","XRWebGLBinding","addEventListener","updateReflection","requestAnimationFrame","_createClass","key","value","textureProperties","properties","get","cubeMap","getReflectionCubeMap","__webglTexture","needsPMREMUpdate","time","xrFrame","lightEstimate","getLightEstimate","sh","fromArray","sphericalHarmonicsCoefficients","intensity","intensityScalar","Math","max","primaryLightIntensity","x","y","z","directionalLight","color","setRGB","position","copy","primaryLightDirection","dispose","XREstimatedLight","_Group","_inherits","_super","_createSuper","_this2","arguments","length","undefined","call","add","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","then","probe","_assertThisInitialized","dispatchEvent","type","remove"],"sources":["C:/Users/Padmavati Shankar/3D-WebXR-Furniture/node_modules/three/examples/jsm/webxr/XREstimatedLight.js"],"sourcesContent":["import {\n\tDirectionalLight,\n\tGroup,\n\tLightProbe,\n\tWebGLCubeRenderTarget\n} from 'three';\n\nclass SessionLightProbe {\n\n\tconstructor( xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback ) {\n\n\t\tthis.xrLight = xrLight;\n\t\tthis.renderer = renderer;\n\t\tthis.lightProbe = lightProbe;\n\t\tthis.xrWebGLBinding = null;\n\t\tthis.estimationStartCallback = estimationStartCallback;\n\t\tthis.frameCallback = this.onXRFrame.bind( this );\n\n\t\tconst session = renderer.xr.getSession();\n\n\t\t// If the XRWebGLBinding class is available then we can also query an\n\t\t// estimated reflection cube map.\n\t\tif ( environmentEstimation && 'XRWebGLBinding' in window ) {\n\n\t\t\t// This is the simplest way I know of to initialize a WebGL cubemap in Three.\n\t\t\tconst cubeRenderTarget = new WebGLCubeRenderTarget( 16 );\n\t\t\txrLight.environment = cubeRenderTarget.texture;\n\n\t\t\tconst gl = renderer.getContext();\n\n\t\t\t// Ensure that we have any extensions needed to use the preferred cube map format.\n\t\t\tswitch ( session.preferredReflectionFormat ) {\n\n\t\t\t\tcase 'srgba8':\n\t\t\t\t\tgl.getExtension( 'EXT_sRGB' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rgba16f':\n\t\t\t\t\tgl.getExtension( 'OES_texture_half_float' );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.xrWebGLBinding = new XRWebGLBinding( session, gl );\n\n\t\t\tthis.lightProbe.addEventListener( 'reflectionchange', () => {\n\n\t\t\t\tthis.updateReflection();\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Start monitoring the XR animation frame loop to look for lighting\n\t\t// estimation changes.\n\t\tsession.requestAnimationFrame( this.frameCallback );\n\n\t}\n\n\tupdateReflection() {\n\n\t\tconst textureProperties = this.renderer.properties.get( this.xrLight.environment );\n\n\t\tif ( textureProperties ) {\n\n\t\t\tconst cubeMap = this.xrWebGLBinding.getReflectionCubeMap( this.lightProbe );\n\n\t\t\tif ( cubeMap ) {\n\n\t\t\t\ttextureProperties.__webglTexture = cubeMap;\n\n\t\t\t\tthis.xrLight.environment.needsPMREMUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tonXRFrame( time, xrFrame ) {\n\n\t\t// If either this obejct or the XREstimatedLight has been destroyed, stop\n\t\t// running the frame loop.\n\t\tif ( ! this.xrLight ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst session = xrFrame.session;\n\t\tsession.requestAnimationFrame( this.frameCallback );\n\n\t\tconst lightEstimate = xrFrame.getLightEstimate( this.lightProbe );\n\t\tif ( lightEstimate ) {\n\n\t\t\t// We can copy the estimate's spherical harmonics array directly into the light probe.\n\t\t\tthis.xrLight.lightProbe.sh.fromArray( lightEstimate.sphericalHarmonicsCoefficients );\n\t\t\tthis.xrLight.lightProbe.intensity = 1.0;\n\n\t\t\t// For the directional light we have to normalize the color and set the scalar as the\n\t\t\t// intensity, since WebXR can return color values that exceed 1.0.\n\t\t\tconst intensityScalar = Math.max( 1.0,\n\t\t\t\tMath.max( lightEstimate.primaryLightIntensity.x,\n\t\t\t\t\tMath.max( lightEstimate.primaryLightIntensity.y,\n\t\t\t\t\t\tlightEstimate.primaryLightIntensity.z ) ) );\n\n\t\t\tthis.xrLight.directionalLight.color.setRGB(\n\t\t\t\tlightEstimate.primaryLightIntensity.x / intensityScalar,\n\t\t\t\tlightEstimate.primaryLightIntensity.y / intensityScalar,\n\t\t\t\tlightEstimate.primaryLightIntensity.z / intensityScalar );\n\t\t\tthis.xrLight.directionalLight.intensity = intensityScalar;\n\t\t\tthis.xrLight.directionalLight.position.copy( lightEstimate.primaryLightDirection );\n\n\t\t\tif ( this.estimationStartCallback ) {\n\n\t\t\t\tthis.estimationStartCallback();\n\t\t\t\tthis.estimationStartCallback = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.xrLight = null;\n\t\tthis.renderer = null;\n\t\tthis.lightProbe = null;\n\t\tthis.xrWebGLBinding = null;\n\n\t}\n\n}\n\nexport class XREstimatedLight extends Group {\n\n\tconstructor( renderer, environmentEstimation = true ) {\n\n\t\tsuper();\n\n\t\tthis.lightProbe = new LightProbe();\n\t\tthis.lightProbe.intensity = 0;\n\t\tthis.add( this.lightProbe );\n\n\t\tthis.directionalLight = new DirectionalLight();\n\t\tthis.directionalLight.intensity = 0;\n\t\tthis.add( this.directionalLight );\n\n\t\t// Will be set to a cube map in the SessionLightProbe is environment estimation is\n\t\t// available and requested.\n\t\tthis.environment = null;\n\n\t\tlet sessionLightProbe = null;\n\t\tlet estimationStarted = false;\n\t\trenderer.xr.addEventListener( 'sessionstart', () => {\n\n\t\t\tconst session = renderer.xr.getSession();\n\n\t\t\tif ( 'requestLightProbe' in session ) {\n\n\t\t\t\tsession.requestLightProbe( {\n\n\t\t\t\t\treflectionFormat: session.preferredReflectionFormat\n\n\t\t\t\t} ).then( ( probe ) => {\n\n\t\t\t\t\tsessionLightProbe = new SessionLightProbe( this, renderer, probe, environmentEstimation, () => {\n\n\t\t\t\t\t\testimationStarted = true;\n\n\t\t\t\t\t\t// Fired to indicate that the estimated lighting values are now being updated.\n\t\t\t\t\t\tthis.dispatchEvent( { type: 'estimationstart' } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.xr.addEventListener( 'sessionend', () => {\n\n\t\t\tif ( sessionLightProbe ) {\n\n\t\t\t\tsessionLightProbe.dispose();\n\t\t\t\tsessionLightProbe = null;\n\n\t\t\t}\n\n\t\t\tif ( estimationStarted ) {\n\n\t\t\t\t// Fired to indicate that the estimated lighting values are no longer being updated.\n\t\t\t\tthis.dispatchEvent( { type: 'estimationend' } );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Done inline to provide access to sessionLightProbe.\n\t\tthis.dispose = () => {\n\n\t\t\tif ( sessionLightProbe ) {\n\n\t\t\t\tsessionLightProbe.dispose();\n\t\t\t\tsessionLightProbe = null;\n\n\t\t\t}\n\n\t\t\tthis.remove( this.lightProbe );\n\t\t\tthis.lightProbe = null;\n\n\t\t\tthis.remove( this.directionalLight );\n\t\t\tthis.directionalLight = null;\n\n\t\t\tthis.environment = null;\n\n\t\t};\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}